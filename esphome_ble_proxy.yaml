substitutions:
  proxy_id: kitchen_proxy  # Change this for each ESP32 device
  device_name: ble-proxy-${proxy_id}
  friendly_name: "BLE Proxy ${proxy_id}"
  mqtt_topic_prefix: "ble-triangulation"

esphome:
  name: "${device_name}"
  friendly_name: "${friendly_name}"
  platform: ESP32
  board: esp32dev

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API (optional - comment out if using MQTT only)
api:
  reboot_timeout: 0s  # Disable reboot if no API connection

# Enable OTA updates
ota:
  password: !secret ota_password

# Enable WiFi
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot in case of connection failure
  ap:
    ssid: "${friendly_name} Fallback"
    password: !secret fallback_ap_password

# Enable MQTT for proxying BLE data
mqtt:
  id: mqtt_client
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  client_id: "${device_name}"
  discovery: true
  discovery_prefix: homeassistant

# Enable BLE tracking
esp32_ble_tracker:
  scan_parameters:
    interval: 1100ms
    window: 1100ms
    active: false
    continuous: true
  on_ble_advertise:
    - then:
        - lambda: |-
            // Only process iBeacon advertisements
            if (x.get_ibeacon().has_value()) {
              auto ibeacon = x.get_ibeacon().value();

              // Get MAC address
              std::string mac_address = x.address_str();

              // Get current time
              auto time = id(homeassistant_time).now();
              char time_str[25];
              strftime(time_str, sizeof(time_str), "%Y-%m-%dT%H:%M:%SZ", time.to_c_tm());

              // Create JSON payload
              std::string payload = "{";
              payload += "\"proxy_id\":\"${proxy_id}\",";
              payload += "\"beacon_mac\":\"" + mac_address + "\",";
              payload += "\"rssi\":" + std::to_string(x.get_rssi()) + ",";
              payload += "\"uuid\":\"" + ibeacon.get_uuid().to_string() + "\",";
              payload += "\"major\":" + std::to_string(ibeacon.get_major()) + ",";
              payload += "\"minor\":" + std::to_string(ibeacon.get_minor()) + ",";
              payload += "\"tx_power\":" + std::to_string(ibeacon.get_signal_power()) + ",";
              payload += "\"timestamp\":\"" + std::string(time_str) + "\"";
              payload += "}";

              // Publish to MQTT
              id(mqtt_client).publish("${mqtt_topic_prefix}/${proxy_id}", payload);

              // Optional: Log for debugging
              ESP_LOGD("ble_tracker", "Published iBeacon: %s", payload.c_str());
            }

# Time component to provide accurate timestamps
time:
  - platform: homeassistant
    id: homeassistant_time

# Sensors to monitor system health
sensor:
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    update_interval: 60s

  - platform: uptime
    name: "${friendly_name} Uptime"
    update_interval: 60s
    unit_of_measurement: seconds

  # Only include if your ESP32 supports internal temperature
  # - platform: internal_temperature
  #   name: "${friendly_name} Temperature"
  #   update_interval: 60s

# Binary sensor for connection status
binary_sensor:
  - platform: status
    name: "${friendly_name} Status"

# Text sensor to report the proxy ID for easier identification
text_sensor:
  - platform: template
    name: "${friendly_name} Proxy ID"
    lambda: |-
      return {"${proxy_id}"};
    update_interval: never
    icon: "mdi:identifier"

# Switch to restart the ESP32
switch:
  - platform: restart
    name: "${friendly_name} Restart"