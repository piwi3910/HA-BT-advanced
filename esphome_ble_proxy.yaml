substitutions:
  proxy_id: kitchen_proxy  # Change this for each ESP32 device
  device_name: ble-proxy-${proxy_id}
  friendly_name: "BLE Proxy ${proxy_id}"
  mqtt_topic_prefix: "ble-triangulation"

esphome:
  name: "${device_name}"
  friendly_name: "${friendly_name}"
  platform: ESP32
  board: esp32dev

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API (optional - comment out if using MQTT only)
api:
  reboot_timeout: 0s  # Disable reboot if no API connection

# Enable OTA updates
ota:
  password: !secret ota_password

# Enable WiFi
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot in case of connection failure
  ap:
    ssid: "${friendly_name} Fallback"
    password: !secret fallback_ap_password

# Enable MQTT for proxying BLE data
mqtt:
  id: mqtt_client
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  client_id: "${device_name}"
  discovery: true
  discovery_prefix: homeassistant

# Enable BLE tracking
esp32_ble_tracker:
  scan_parameters:
    interval: 1100ms
    window: 1100ms
    active: false
    continuous: true
  on_ble_advertise:
    - then:
        - lambda: |-
            // Get MAC address and RSSI (common to all beacon types)
            std::string mac_address = x.address_str();
            int rssi = x.get_rssi();

            // Get current time
            auto time = id(homeassistant_time).now();
            char time_str[25];
            strftime(time_str, sizeof(time_str), "%Y-%m-%dT%H:%M:%SZ", time.to_c_tm());

            // Start building JSON payload with common fields
            std::string payload = "{";
            payload += "\"proxy_id\":\"${proxy_id}\",";
            payload += "\"beacon_mac\":\"" + mac_address + "\",";
            payload += "\"rssi\":" + std::to_string(rssi) + ",";
            payload += "\"timestamp\":\"" + std::string(time_str) + "\"";

            // Process iBeacon advertisements
            if (x.get_ibeacon().has_value()) {
              auto ibeacon = x.get_ibeacon().value();

              payload += ",\"frame_type\":\"ibeacon\"";
              payload += ",\"uuid\":\"" + ibeacon.get_uuid().to_string() + "\"";
              payload += ",\"major\":" + std::to_string(ibeacon.get_major());
              payload += ",\"minor\":" + std::to_string(ibeacon.get_minor());
              payload += ",\"tx_power\":" + std::to_string(ibeacon.get_signal_power());

              payload += "}";
              id(mqtt_client).publish("${mqtt_topic_prefix}/${proxy_id}", payload);
              ESP_LOGD("ble_tracker", "Published iBeacon: %s", payload.c_str());
            }
            // Process Eddystone advertisements
            else if (x.get_service_data_uuid() == esp32_ble_tracker::ESPBTUUID::from_uint16(0xFEAA)) {
              // Eddystone uses service UUID 0xFEAA
              auto data = x.get_service_data();

              if (data.size() > 0) {
                uint8_t frame_type = data[0];

                // Eddystone-UID (0x00)
                if (frame_type == 0x00 && data.size() >= 20) {
                  payload += ",\"frame_type\":\"eddystone-uid\"";
                  payload += ",\"tx_power\":" + std::to_string((int8_t)data[1]);

                  // Extract namespace (10 bytes)
                  char namespace_hex[21];
                  sprintf(namespace_hex, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
                    data[2], data[3], data[4], data[5], data[6],
                    data[7], data[8], data[9], data[10], data[11]);
                  payload += ",\"eddystone_namespace\":\"" + std::string(namespace_hex) + "\"";

                  // Extract instance (6 bytes)
                  char instance_hex[13];
                  sprintf(instance_hex, "%02x%02x%02x%02x%02x%02x",
                    data[12], data[13], data[14], data[15], data[16], data[17]);
                  payload += ",\"eddystone_instance\":\"" + std::string(instance_hex) + "\"";

                  payload += "}";
                  id(mqtt_client).publish("${mqtt_topic_prefix}/${proxy_id}", payload);
                  ESP_LOGD("ble_tracker", "Published Eddystone-UID: %s", payload.c_str());
                }
                // Eddystone-TLM (0x20) - Telemetry data
                else if (frame_type == 0x20 && data.size() >= 14) {
                  payload += ",\"frame_type\":\"eddystone-tlm\"";

                  // TLM version
                  uint8_t tlm_version = data[1];
                  payload += ",\"tlm_version\":" + std::to_string(tlm_version);

                  if (tlm_version == 0x00) {  // Unencrypted TLM
                    // Battery voltage in mV (2 bytes, big endian)
                    uint16_t battery_mv = (data[2] << 8) | data[3];
                    payload += ",\"battery_voltage\":" + std::to_string(battery_mv);

                    // Temperature in 8.8 fixed point format (2 bytes, big endian)
                    int16_t temp_raw = (data[4] << 8) | data[5];
                    float temperature = temp_raw / 256.0;
                    payload += ",\"temperature\":" + std::to_string(temperature);

                    // Advertising PDU count (4 bytes, big endian)
                    uint32_t pdu_count = (data[6] << 24) | (data[7] << 16) | (data[8] << 8) | data[9];
                    payload += ",\"packet_count\":" + std::to_string(pdu_count);

                    // Time since power-on in 0.1 second units (4 bytes, big endian)
                    uint32_t time_units = (data[10] << 24) | (data[11] << 16) | (data[12] << 8) | data[13];
                    uint32_t uptime_seconds = time_units / 10;
                    payload += ",\"uptime_seconds\":" + std::to_string(uptime_seconds);
                  }

                  payload += "}";
                  id(mqtt_client).publish("${mqtt_topic_prefix}/${proxy_id}", payload);
                  ESP_LOGD("ble_tracker", "Published Eddystone-TLM: %s", payload.c_str());
                }
                // Eddystone-URL (0x10)
                else if (frame_type == 0x10 && data.size() >= 3) {
                  payload += ",\"frame_type\":\"eddystone-url\"";
                  payload += ",\"tx_power\":" + std::to_string((int8_t)data[1]);

                  // URL scheme prefix
                  const char* url_schemes[] = {"http://www.", "https://www.", "http://", "https://"};
                  uint8_t scheme = data[2];
                  std::string url = "";

                  if (scheme < 4) {
                    url = url_schemes[scheme];
                  }

                  // Decode URL
                  for (size_t i = 3; i < data.size(); i++) {
                    uint8_t byte = data[i];
                    if (byte < 14) {
                      // Special expansion codes
                      const char* expansions[] = {
                        ".com/", ".org/", ".edu/", ".net/", ".info/", ".biz/",
                        ".gov/", ".com", ".org", ".edu", ".net", ".info", ".biz", ".gov"
                      };
                      url += expansions[byte];
                    } else if (byte >= 32 && byte <= 126) {
                      // Printable ASCII
                      url += (char)byte;
                    }
                  }

                  payload += ",\"eddystone_url\":\"" + url + "\"";
                  payload += "}";
                  id(mqtt_client).publish("${mqtt_topic_prefix}/${proxy_id}", payload);
                  ESP_LOGD("ble_tracker", "Published Eddystone-URL: %s", payload.c_str());
                }
              }
            }
            // Process other BLE advertisements (for future expansion)
            else {
              // Could handle other beacon types here (AltBeacon, RuuviTag, etc.)
              // For now, just log that we saw something else
              ESP_LOGV("ble_tracker", "Unhandled advertisement from %s", mac_address.c_str());
            }

# Time component to provide accurate timestamps
time:
  - platform: homeassistant
    id: homeassistant_time

# Sensors to monitor system health
sensor:
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    update_interval: 60s

  - platform: uptime
    name: "${friendly_name} Uptime"
    update_interval: 60s
    unit_of_measurement: seconds

  # Only include if your ESP32 supports internal temperature
  # - platform: internal_temperature
  #   name: "${friendly_name} Temperature"
  #   update_interval: 60s

# Binary sensor for connection status
binary_sensor:
  - platform: status
    name: "${friendly_name} Status"

# Text sensor to report the proxy ID for easier identification
text_sensor:
  - platform: template
    name: "${friendly_name} Proxy ID"
    lambda: |-
      return {"${proxy_id}"};
    update_interval: never
    icon: "mdi:identifier"

# Switch to restart the ESP32
switch:
  - platform: restart
    name: "${friendly_name} Restart"