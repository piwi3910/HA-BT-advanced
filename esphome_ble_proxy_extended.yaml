# Extended BLE Proxy Configuration for Triangulation
# This configuration extends any official ESPHome Bluetooth Proxy package
# with BLE triangulation capabilities

substitutions:
  # Modify these for your device
  name: your-device-name
  friendly_name: "Your Device Friendly Name"
  proxy_id: your_proxy_id  # Unique ID for triangulation (e.g., living_room, kitchen)
  mqtt_topic_prefix: "ble-triangulation"

packages:
  # Choose your base package based on your hardware:

  # For Generic ESP32:
  # esphome.bluetooth-proxy: github://esphome/bluetooth-proxies/esp32-generic.yaml@main

  # For Olimex ESP32-POE-ISO:
  # esphome.bluetooth-proxy: github://esphome/bluetooth-proxies/olimex/olimex-esp32-poe-iso.yaml@main

  # For Olimex ESP32-POE:
  # esphome.bluetooth-proxy: github://esphome/bluetooth-proxies/olimex/olimex-esp32-poe.yaml@main

  # For M5Stack Atom Lite:
  # esphome.bluetooth-proxy: github://esphome/bluetooth-proxies/m5stack-atom-lite.yaml@main

  # For M5Stack Atom Echo:
  # esphome.bluetooth-proxy: github://esphome/bluetooth-proxies/m5stack-atom-echo.yaml@main

  # For ESP32-C3:
  # esphome.bluetooth-proxy: github://esphome/bluetooth-proxies/esp32-c3.yaml@main

  # For Shelly Plus Devices:
  # esphome.bluetooth-proxy: github://esphome/bluetooth-proxies/shelly-plus.yaml@main

  # For GL.iNet GL-S10:
  # esphome.bluetooth-proxy: github://esphome/bluetooth-proxies/gl-s10.yaml@main

esphome:
  name: ${name}
  name_add_mac_suffix: false
  friendly_name: ${friendly_name}

# API configuration (if not using from package)
api:
  encryption:
    key: !secret api_encryption_key
  reboot_timeout: 0s  # Disable reboot when using MQTT

# Add MQTT for BLE triangulation data
mqtt:
  id: mqtt_client
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  client_id: "${name}"
  discovery: true
  discovery_prefix: homeassistant
  on_connect:
    - then:
        - lambda: |-
            // Publish proxy status with metadata
            std::string status_payload = "{";
            status_payload += "\"status\":\"online\",";
            status_payload += "\"proxy_id\":\"${proxy_id}\",";
            status_payload += "\"ip_address\":\"" + WiFi.localIP().toString().c_str() + "\",";
            status_payload += "\"mac_address\":\"" + get_mac_address_pretty() + "\",";
            status_payload += "\"esphome_version\":\"" ESPHOME_VERSION "\",";
            status_payload += "\"hardware\":\"ESP32\",";
            status_payload += "\"board\":\"${board}\",";
            status_payload += "\"wifi_ssid\":\"" + WiFi.SSID().c_str() + "\",";
            status_payload += "\"wifi_rssi\":" + std::to_string(WiFi.RSSI()) + ",";
            status_payload += "\"free_heap\":" + std::to_string(ESP.getFreeHeap()) + ",";
            status_payload += "\"uptime\":" + std::to_string(millis() / 1000) + ",";

            // Add temperature if available
            if (!std::isnan(id(internal_temp).state)) {
              status_payload += "\"temperature\":" + std::to_string(id(internal_temp).state) + ",";
            }

            status_payload += "\"timestamp\":\"" + id(homeassistant_time).now().strftime("%Y-%m-%dT%H:%M:%SZ") + "\"";
            status_payload += "}";

            id(mqtt_client).publish("${mqtt_topic_prefix}/proxy/${proxy_id}/status", status_payload);
            ESP_LOGI("mqtt", "Published proxy status: %s", status_payload.c_str());
  on_disconnect:
    - then:
        - mqtt.publish_json:
            topic: "${mqtt_topic_prefix}/proxy/${proxy_id}/status"
            payload: |-
              root["status"] = "offline";
              root["proxy_id"] = "${proxy_id}";
              root["timestamp"] = id(homeassistant_time).now().strftime("%Y-%m-%dT%H:%M:%SZ");

# Extend the BLE tracker with triangulation logic
esp32_ble_tracker:
  on_ble_advertise:
    - then:
        - lambda: |-
            // Get MAC address and RSSI (common to all beacon types)
            std::string mac_address = x.address_str();
            int rssi = x.get_rssi();

            // Get current time
            auto time = id(homeassistant_time).now();
            char time_str[25];
            strftime(time_str, sizeof(time_str), "%Y-%m-%dT%H:%M:%SZ", time.to_c_tm());

            // Start building JSON payload with common fields
            std::string payload = "{";
            payload += "\"proxy_id\":\"${proxy_id}\",";
            payload += "\"beacon_mac\":\"" + mac_address + "\",";
            payload += "\"rssi\":" + std::to_string(rssi) + ",";
            payload += "\"timestamp\":\"" + std::string(time_str) + "\"";

            // Process iBeacon advertisements
            if (x.get_ibeacon().has_value()) {
              auto ibeacon = x.get_ibeacon().value();

              payload += ",\"frame_type\":\"ibeacon\"";
              payload += ",\"uuid\":\"" + ibeacon.get_uuid().to_string() + "\"";
              payload += ",\"major\":" + std::to_string(ibeacon.get_major());
              payload += ",\"minor\":" + std::to_string(ibeacon.get_minor());
              payload += ",\"tx_power\":" + std::to_string(ibeacon.get_signal_power());

              payload += "}";
              id(mqtt_client).publish("${mqtt_topic_prefix}/${proxy_id}", payload);

              // Update beacon counter
              id(beacon_counter) += 1;

              ESP_LOGD("ble_tracker", "Published iBeacon: %s", payload.c_str());
            }

            // Process Eddystone advertisements (check independently from iBeacon)
            // Check for Eddystone service UUID 0xFEAA
            for (auto &service_data : x.get_service_datas()) {
              if (service_data.uuid == esp32_ble_tracker::ESPBTUUID::from_uint16(0xFEAA)) {
                // Eddystone uses service UUID 0xFEAA
                auto data = service_data.data;

              if (data.size() > 0) {
                uint8_t frame_type = data[0];

                // Eddystone-UID (0x00)
                if (frame_type == 0x00 && data.size() >= 20) {
                  payload += ",\"frame_type\":\"eddystone-uid\"";
                  payload += ",\"tx_power\":" + std::to_string((int8_t)data[1]);

                  // Extract namespace (10 bytes)
                  char namespace_hex[21];
                  sprintf(namespace_hex, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
                    data[2], data[3], data[4], data[5], data[6],
                    data[7], data[8], data[9], data[10], data[11]);
                  payload += ",\"eddystone_namespace\":\"" + std::string(namespace_hex) + "\"";

                  // Extract instance (6 bytes)
                  char instance_hex[13];
                  sprintf(instance_hex, "%02x%02x%02x%02x%02x%02x",
                    data[12], data[13], data[14], data[15], data[16], data[17]);
                  payload += ",\"eddystone_instance\":\"" + std::string(instance_hex) + "\"";

                  payload += "}";
                  id(mqtt_client).publish("${mqtt_topic_prefix}/${proxy_id}", payload);
                  ESP_LOGD("ble_tracker", "Published Eddystone-UID: %s", payload.c_str());
                }
                // Eddystone-TLM (0x20) - Telemetry data
                else if (frame_type == 0x20 && data.size() >= 14) {
                  payload += ",\"frame_type\":\"eddystone-tlm\"";

                  // TLM version
                  uint8_t tlm_version = data[1];
                  payload += ",\"tlm_version\":" + std::to_string(tlm_version);

                  if (tlm_version == 0x00) {  // Unencrypted TLM
                    // Battery voltage in mV (2 bytes, big endian)
                    uint16_t battery_mv = (data[2] << 8) | data[3];
                    payload += ",\"battery_voltage\":" + std::to_string(battery_mv);

                    // Temperature in 8.8 fixed point format (2 bytes, big endian)
                    int16_t temp_raw = (data[4] << 8) | data[5];
                    float temperature = temp_raw / 256.0;
                    payload += ",\"temperature\":" + std::to_string(temperature);

                    // Advertising PDU count (4 bytes, big endian)
                    uint32_t pdu_count = (data[6] << 24) | (data[7] << 16) | (data[8] << 8) | data[9];
                    payload += ",\"packet_count\":" + std::to_string(pdu_count);

                    // Time since power-on in 0.1 second units (4 bytes, big endian)
                    uint32_t time_units = (data[10] << 24) | (data[11] << 16) | (data[12] << 8) | data[13];
                    uint32_t uptime_seconds = time_units / 10;
                    payload += ",\"uptime_seconds\":" + std::to_string(uptime_seconds);
                  }

                  payload += "}";
                  id(mqtt_client).publish("${mqtt_topic_prefix}/${proxy_id}", payload);
                  ESP_LOGD("ble_tracker", "Published Eddystone-TLM: %s", payload.c_str());
                }
                // Eddystone-URL (0x10)
                else if (frame_type == 0x10 && data.size() >= 3) {
                  payload += ",\"frame_type\":\"eddystone-url\"";
                  payload += ",\"tx_power\":" + std::to_string((int8_t)data[1]);

                  // URL scheme prefix
                  const char* url_schemes[] = {"http://www.", "https://www.", "http://", "https://"};
                  uint8_t scheme = data[2];
                  std::string url = "";

                  if (scheme < 4) {
                    url = url_schemes[scheme];
                  }

                  // Decode URL
                  for (size_t i = 3; i < data.size(); i++) {
                    uint8_t byte = data[i];
                    if (byte < 14) {
                      // Special expansion codes
                      const char* expansions[] = {
                        ".com/", ".org/", ".edu/", ".net/", ".info/", ".biz/",
                        ".gov/", ".com", ".org", ".edu", ".net", ".info", ".biz", ".gov"
                      };
                      url += expansions[byte];
                    } else if (byte >= 32 && byte <= 126) {
                      // Printable ASCII
                      url += (char)byte;
                    }
                  }

                  payload += ",\"eddystone_url\":\"" + url + "\"";
                  payload += "}";
                  id(mqtt_client).publish("${mqtt_topic_prefix}/${proxy_id}", payload);
                  ESP_LOGD("ble_tracker", "Published Eddystone-URL: %s", payload.c_str());
                }
                break; // Found Eddystone, no need to check other service data
              }
            }

            // Log unhandled advertisement types for debugging
            // Note: A beacon may send multiple frame types (iBeacon, Eddystone, etc.)
            // so we only log if NONE of the above matched
            // Log unhandled advertisement types (simplified check)
            if (!x.get_ibeacon().has_value()) {
              bool has_eddystone = false;
              for (auto &service_data : x.get_service_datas()) {
                if (service_data.uuid == esp32_ble_tracker::ESPBTUUID::from_uint16(0xFEAA)) {
                  has_eddystone = true;
                  break;
                }
              }
              if (!has_eddystone) {
                ESP_LOGV("ble_tracker", "Unhandled advertisement type from %s", mac_address.c_str());
              }
            }

# Time component for timestamps
time:
  - platform: homeassistant
    id: homeassistant_time

# Sensors to monitor system health (also included in proxy status messages)
sensor:
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    id: wifi_signal_sensor
    update_interval: 60s

  - platform: uptime
    name: "${friendly_name} Uptime"
    id: uptime_sensor
    update_interval: 60s
    unit_of_measurement: seconds

  # Internal temperature (uncomment if your ESP32 supports it)
  - platform: internal_temperature
    name: "${friendly_name} Temperature"
    id: internal_temp
    update_interval: 60s

  # Free heap memory
  - platform: template
    name: "${friendly_name} Free Memory"
    id: free_heap
    lambda: |-
      return ESP.getFreeHeap();
    unit_of_measurement: "bytes"
    update_interval: 60s

  # WiFi RSSI
  - platform: wifi_signal
    name: "${friendly_name} WiFi RSSI"
    id: wifi_rssi
    update_interval: 60s

  # Beacon counter
  - platform: template
    name: "${friendly_name} Beacon Count"
    id: beacon_count_sensor
    lambda: |-
      return id(beacon_counter);
    unit_of_measurement: "beacons"
    icon: "mdi:bluetooth"

# Global variable for beacon counter
globals:
  - id: beacon_counter
    type: int
    restore_value: no
    initial_value: '0'

# Binary sensor for connection status
binary_sensor:
  - platform: status
    name: "${friendly_name} Status"

# Text sensors for network info
text_sensor:
  - platform: template
    name: "${friendly_name} Proxy ID"
    lambda: |-
      return {"${proxy_id}"};
    update_interval: never
    icon: "mdi:identifier"

  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP Address"
      id: ip_address
    ssid:
      name: "${friendly_name} Connected SSID"
      id: connected_ssid
    mac_address:
      name: "${friendly_name} MAC Address"
      id: mac_address

# Switch to restart the ESP32
switch:
  - platform: restart
    name: "${friendly_name} Restart"

# Periodic status update
interval:
  - interval: 60s
    then:
      - lambda: |-
          // Publish proxy status update every 60 seconds
          std::string status_payload = "{";
          status_payload += "\"status\":\"online\",";
          status_payload += "\"proxy_id\":\"${proxy_id}\",";

          // Network info
          status_payload += "\"ip_address\":\"" + id(ip_address).state + "\",";
          status_payload += "\"mac_address\":\"" + id(mac_address).state + "\",";
          status_payload += "\"wifi_ssid\":\"" + id(connected_ssid).state + "\",";
          status_payload += "\"wifi_rssi\":" + std::to_string((int)id(wifi_rssi).state) + ",";
          status_payload += "\"wifi_signal\":" + std::to_string((int)id(wifi_signal_sensor).state) + ",";

          // System info
          status_payload += "\"hardware\":\"ESP32\",";
          status_payload += "\"board\":\"${board}\",";
          status_payload += "\"esphome_version\":\"" ESPHOME_VERSION "\",";

          // Memory and performance
          status_payload += "\"free_heap\":" + std::to_string((int)id(free_heap).state) + ",";
          status_payload += "\"uptime\":" + std::to_string((int)id(uptime_sensor).state) + ",";
          status_payload += "\"beacon_count\":" + std::to_string(id(beacon_counter)) + ",";

          // Temperature if available
          if (!std::isnan(id(internal_temp).state)) {
            status_payload += "\"temperature\":" + std::to_string(id(internal_temp).state) + ",";
          }

          // CPU frequency
          status_payload += "\"cpu_frequency\":" + std::to_string(ESP.getCpuFreqMHz()) + ",";

          // Flash chip info
          status_payload += "\"flash_size\":" + std::to_string(ESP.getFlashChipSize()) + ",";

          // Timestamp
          auto time = id(homeassistant_time).now();
          if (time.is_valid()) {
            status_payload += "\"timestamp\":\"" + time.strftime("%Y-%m-%dT%H:%M:%SZ") + "\"";
          } else {
            status_payload += "\"timestamp\":null";
          }

          status_payload += "}";

          id(mqtt_client).publish("${mqtt_topic_prefix}/proxy/${proxy_id}/status", status_payload, 0, true);
          ESP_LOGD("mqtt", "Published proxy heartbeat");