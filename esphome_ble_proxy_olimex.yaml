# Olimex ESP32-POE-ISO with BLE Triangulation
# Extends the official Bluetooth Proxy with triangulation features

substitutions:
  name: olimex-esp32-poe-iso-ad1678
  friendly_name: "Bluetooth Proxy ad1678"
  proxy_id: olimex_ad1678  # Unique ID for triangulation
  mqtt_topic_prefix: "ble-triangulation"

packages:
  # Use the official Olimex ESP32-POE-ISO Bluetooth Proxy package
  esphome.bluetooth-proxy: github://esphome/bluetooth-proxies/olimex/olimex-esp32-poe-iso.yaml@main

esphome:
  name: ${name}
  name_add_mac_suffix: false
  friendly_name: ${friendly_name}

# API encryption key (required by base package)
# Set reboot_timeout to 0 to prevent conflicts with MQTT
api:
  encryption:
    key: !secret api_encryption_key
  reboot_timeout: 0s  # Disable reboot on API disconnect to allow MQTT to work

# Add MQTT for BLE triangulation
mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  discovery: true
  topic_prefix: "${name}"
  on_connect:
    - logger.log: "MQTT Connected!"
    - mqtt.publish:
        topic: "${mqtt_topic_prefix}/status/${proxy_id}"
        payload: "online"
  on_disconnect:
    - logger.log: "MQTT Disconnected!"

# Script to publish BLE iBeacon data
script:
  - id: publish_ibeacon
    mode: queued
    parameters:
      mac: string
      rssi: int
      uuid: string
      major: int
      minor: int
      tx_power: int
    then:
      - mqtt.publish_json:
          topic: "${mqtt_topic_prefix}/${proxy_id}"
          payload: |-
            root["proxy_id"] = "${proxy_id}";
            root["beacon_mac"] = mac;
            root["rssi"] = rssi;
            root["uuid"] = uuid;
            root["major"] = major;
            root["minor"] = minor;
            root["tx_power"] = tx_power;

# Process BLE advertisements for triangulation
esp32_ble_tracker:
  on_ble_advertise:
    - then:
        - lambda: |-
            if (x.get_ibeacon().has_value()) {
              auto ibeacon = x.get_ibeacon().value();

              // Get MAC address as string
              std::string mac_str = x.address_str();

              // Publish via script
              id(publish_ibeacon).execute(
                mac_str,
                x.get_rssi(),
                ibeacon.get_uuid().to_string(),
                ibeacon.get_major(),
                ibeacon.get_minor(),
                ibeacon.get_signal_power()
              );
            }

# Text sensor for proxy identification
text_sensor:
  - platform: template
    name: "${friendly_name} Proxy ID"
    lambda: |-
      return {"${proxy_id}"};
    update_interval: never
    icon: "mdi:identifier"
    entity_category: diagnostic