# Olimex ESP32-POE-ISO with BLE Triangulation
# Extends the official Bluetooth Proxy with triangulation features

substitutions:
  name: olimex-esp32-poe-iso-ad1678
  friendly_name: "Bluetooth Proxy ad1678"
  proxy_id: olimex_ad1678  # Unique ID for triangulation
  mqtt_topic_prefix: "ble-triangulation"

packages:
  # Use the official Olimex ESP32-POE-ISO Bluetooth Proxy package
  esphome.bluetooth-proxy: github://esphome/bluetooth-proxies/olimex/olimex-esp32-poe-iso.yaml@main

esphome:
  name: ${name}
  name_add_mac_suffix: false
  friendly_name: ${friendly_name}

# API encryption key (required by base package)
api:
  encryption:
    key: !secret api_encryption_key

# Add MQTT for BLE triangulation
mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  discovery: true
  topic_prefix: "${name}"

# Script to publish BLE iBeacon data
script:
  - id: publish_ibeacon
    mode: queued
    parameters:
      mac: string
      rssi: int
      uuid: string
      major: int
      minor: int
      tx_power: int
    then:
      - mqtt.publish_json:
          topic: "${mqtt_topic_prefix}/${proxy_id}"
          payload: |-
            root["proxy_id"] = "${proxy_id}";
            root["beacon_mac"] = mac;
            root["rssi"] = rssi;
            root["uuid"] = uuid;
            root["major"] = major;
            root["minor"] = minor;
            root["tx_power"] = tx_power;

# Process BLE advertisements for triangulation
esp32_ble_tracker:
  on_ble_advertise:
    - then:
        - lambda: |-
            if (x.get_ibeacon().has_value()) {
              auto ibeacon = x.get_ibeacon().value();

              char mac_str[18];
              sprintf(mac_str, "%02X:%02X:%02X:%02X:%02X:%02X",
                      x.address[0], x.address[1], x.address[2],
                      x.address[3], x.address[4], x.address[5]);

              // Publish via script
              id(publish_ibeacon).execute(
                std::string(mac_str),
                x.get_rssi(),
                ibeacon.get_uuid().to_string(),
                ibeacon.get_major(),
                ibeacon.get_minor(),
                ibeacon.get_signal_power()
              );
            }

# Text sensor for proxy identification
text_sensor:
  - platform: template
    name: "${friendly_name} Proxy ID"
    lambda: |-
      return {"${proxy_id}"};
    update_interval: never
    icon: "mdi:identifier"
    entity_category: diagnostic